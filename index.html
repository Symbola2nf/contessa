<!DOCTYPE html>

<html dir="rtl" lang="ar">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"/>
<title>ŸÑÿπÿ®ÿ© Coup 3D</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&amp;display=swap" rel="stylesheet"/>
<style>:root {
            --yellow-glow: #fde047;
            --dark-bg: #1a1a1a;
            --dark-ui: rgba(0, 0, 0, 0.7);
        }
        body {
            font-family: 'Cairo', sans-serif;
            overflow: hidden;
            background-color: var(--dark-bg);
            color: white;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--dark-bg);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
            transition: opacity 0.5s ease;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-left-color: var(--yellow-glow);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .ui-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        .ui-element {
            pointer-events: auto;
            background-color: var(--dark-ui);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .player-info {
            position: absolute;
            text-align: center;
            transform: translateX(-50%);
            transition: all 0.3s ease;
            width: 120px; 
        }
        .player-info .avatar {
            width: 60px; height: 60px; /* Increased size for avatars */
            background-color: #4a4a4a;
            border-radius: 50%;
            border: 2px solid white;
            margin: 0 auto 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            overflow: hidden; /* To contain the SVG */
        }
        .player-info .avatar svg {
            width: 100%;
            height: 100%;
        }
        .player-info.current-turn .avatar {
            border-color: var(--yellow-glow);
            box-shadow: 0 0 15px var(--yellow-glow), 0 0 25px var(--yellow-glow);
        }
        .player-info.eliminated {
            opacity: 0.4;
            filter: grayscale(1);
        }
        .bottom-ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 10px;
            box-sizing: border-box;
            pointer-events: none;
        }
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            max-width: 95%;
            width: 100%;
            pointer-events: auto;
        }
        .action-btn {
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            flex-shrink: 0;
        }
        .action-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            background: linear-gradient(145deg, #6a6a6a, #4a4a4a);
        }
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #lobby, #game-over-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            overflow-y: auto;
        }
        #lobby input {
            color: black;
            padding: 10px;
            border-radius: 8px;
            border: none;
            width: 100%;
            max-width: 300px;
            text-align: center;
        }
        #lobby button, #game-over-screen button {
            background: var(--yellow-glow);
            color: var(--dark-bg);
            font-weight: bold;
        }
        .message-log {
            display: none !important;
        }
        .modal {
            position: fixed;
            z-index: 50;
            left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            padding: 15px;
        }
        .modal-content {
            background-color: #2d2d2d;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid var(--yellow-glow);
            width: 100%;
            max-width: 450px;
        }
        .card-selection-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .card-selection-container img {
            width: 80px;
            height: auto;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-radius: 8px;
            border: 2px solid transparent;
        }
        .card-selection-container img:hover {
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 0 15px var(--yellow-glow);
        }
        .card-selection-container img.selected {
            border-color: var(--yellow-glow);
            box-shadow: 0 0 20px var(--yellow-glow);
        }
        #turn-timer {
            position: absolute;
            top: 20px;
            right: 20px;
            transform: none;
            font-size: 24px;
            font-weight: bold;
            color: var(--yellow-glow);
            text-shadow: 0 0 10px var(--yellow-glow);
            display: none;
        }
        .top-right-ui {
            display: none !important;
        }
        
        /* Avatar Customizer Styles */
        #avatar-customizer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        #avatar-preview {
            width: 100px;
            height: 100px;
            background-color: #2a2a2a;
            border: 2px solid var(--yellow-glow);
            border-radius: 50%;
            overflow: hidden;
        }
        .avatar-controls {
            display: flex;
            gap: 10px;
        }
        .avatar-controls button {
            background-color: #4a4a4a;
            border: 1px solid #6a6a6a;
            color: white;
            border-radius: 8px;
            padding: 5px 10px;
            font-size: 12px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .action-btn {
                padding: 12px;
                font-size: 13px;
                min-width: 80px;
            }
            .action-buttons {
                gap: 5px;
            }
            .player-info {
                width: 90px;
            }
            .player-info .avatar {
                width: 45px;
                height: 45px;
            }
            .modal-content {
                padding: 15px;
            }
            .card-selection-container img {
                width: 70px;
            }
            .ui-element {
                padding: 6px 12px;
            }
        }
.bottom-ui-container {
    z-index: 10;
}
.player-info {
    transform: translateX(-50%) translateY(-140px);
    z-index: 20;
}
@media (max-width: 768px) {
    .player-info {
        width: 90px;
    }
    .player-info .avatar {
        width: 45px;
        height: 45px;
    }
}</style>
</head>
<body>
<div id="loading-overlay">
<div class="spinner"></div>
<p>ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÑÿπÿ®ÿ©...</p>
</div>
<div id="game-container"></div>
<div id="lobby" style="display: flex;">
<div class="ui-element text-center">
<h1 class="text-4xl font-bold text-yellow-300 mb-4">ŸÑÿπÿ®ÿ© Coup</h1>
<!-- NEW: Avatar Customizer -->
<div id="avatar-customizer">
<p class="mb-2">ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµŸäÿ™ŸÉ</p>
<div id="avatar-preview"></div>
<div class="avatar-controls">
<button id="prev-shirt-btn">&lt;</button>
<button>ÿßŸÑŸÇŸÖŸäÿµ</button>
<button id="next-shirt-btn">&gt;</button>
</div>
<div class="avatar-controls">
<button id="prev-head-btn">&lt;</button>
<button>ÿßŸÑŸàÿ¨Ÿá</button>
<button id="next-head-btn">&gt;</button>
</div>
</div>
<p class="mb-2">ÿ£ÿØÿÆŸÑ ÿßÿ≥ŸÖŸÉ:</p>
<input class="mb-4" id="player-name-input" placeholder="ÿßÿ≥ŸÖ ÿßŸÑŸÑÿßÿπÿ®" type="text"/>
<p class="mb-2">ÿ£ÿØÿÆŸÑ ÿ±ŸÖÿ≤ ÿßŸÑŸÑÿπÿ®ÿ© ŸÑŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ£Ÿà ÿ£ŸÜÿ¥ÿ¶ ŸÑÿπÿ®ÿ© ÿ¨ÿØŸäÿØÿ©</p>
<input id="game-id-input" placeholder="ÿ±ŸÖÿ≤ ÿßŸÑŸÑÿπÿ®ÿ©" type="text"/>
<div class="flex gap-4 mt-4 justify-center">
<button class="action-btn" id="join-game-btn">ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑŸÑÿπÿ®ÿ©</button>
<button class="action-btn" id="create-game-btn">ÿ•ŸÜÿ¥ÿßÿ° ŸÑÿπÿ®ÿ© ÿ¨ÿØŸäÿØÿ©</button>
</div>
<button class="action-btn mt-4" id="start-game-btn" style="display: none;">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®ÿ©</button>
<p class="text-red-500 mt-4" id="lobby-error"></p>
<div class="mt-4">
<h3 class="text-lg font-bold mb-2">ÿßŸÑŸÑÿßÿπÿ®ŸàŸÜ ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©: <span id="game-id-display"></span></h3>
<ul id="lobby-players-list"></ul>
</div>
</div>
</div>
<div class="ui-overlay" id="ui-overlay" style="display: none;">
<div class="w-full h-full absolute" id="player-infos"></div>
<div class="ui-element" id="turn-timer"></div>
<div class="absolute top-4 right-4 ui-element top-right-ui">
<p>ÿ±ŸÖÿ≤ ÿßŸÑŸÑÿπÿ®ÿ©: <strong id="game-id-ingame"></strong></p>
</div>
<div class="bottom-ui-container">
<div class="message-log" id="message-log"></div>
<div class="action-buttons" id="action-buttons"></div>
</div>
</div>
<div class="modal" id="interaction-modal">
<div class="modal-content ui-element">
<h3 class="text-2xl mb-4" id="modal-title"></h3>
<p class="mb-6" id="modal-text"></p>
<div class="flex justify-center gap-4 flex-wrap" id="modal-buttons"></div>
</div>
</div>
<div class="modal" id="target-selection-modal">
<div class="modal-content ui-element">
<h3 class="text-2xl mb-4">ÿßÿÆÿ™ÿ± ŸÑÿßÿπÿ®Ÿãÿß</h3>
<div class="flex flex-col gap-2" id="target-player-list"></div>
<button class="mt-4 action-btn" id="cancel-target-btn">ÿ•ŸÑÿ∫ÿßÿ°</button>
</div>
</div>
<div class="modal" id="reveal-card-modal">
<div class="modal-content ui-element">
<h3 class="text-2xl mb-4" id="reveal-title"></h3>
<p class="mb-4" id="reveal-text">ÿßÿÆÿ™ÿ± ÿ®ÿ∑ÿßŸÇÿ© ŸÑÿ™ÿÆÿ≥ÿ±Ÿáÿß.</p>
<div class="flex justify-center gap-4 mb-4 card-selection-container" id="reveal-cards-container"></div>
</div>
</div>
<div class="modal" id="exchange-modal">
<div class="modal-content ui-element">
<h3 class="text-2xl mb-4">ÿ™ÿ®ÿØŸäŸÑ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™ (ÿßŸÑÿ≥ŸÅŸäÿ±)</h3>
<p class="mb-4" id="exchange-text">ŸÑÿØŸäŸÉ 4 ÿ®ÿ∑ÿßŸÇÿßÿ™. ÿßÿÆÿ™ÿ± 2 ŸÑŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏ ÿ®ŸáŸÖÿß.</p>
<div class="flex justify-center gap-4 mb-4 card-selection-container" id="exchange-cards-container"></div>
<button class="action-btn" disabled="" id="confirm-exchange-btn">ÿ™ÿ£ŸÉŸäÿØ</button>
</div>
</div>
<div id="game-over-screen" style="display: none;">
<div class="ui-element text-center">
<h1 class="text-4xl font-bold text-yellow-300 mb-4">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!</h1>
<p class="text-2xl" id="winner-text"></p>
<p class="text-sm text-gray-400 mt-4" id="cleanup-text"></p>
<button class="mt-6 action-btn" id="play-again-btn">ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ±ÿØŸáÿ©</button>
</div>
</div>
<script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, serverTimestamp, runTransaction, arrayUnion, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBQLIKtueG954OYiWz-YDBl_LyUxc_VRT8",
            authDomain: "el-klika.firebaseapp.com",
            projectId: "el-klika",
            storageBucket: "el-klika.appspot.com",
            messagingSenderId: "357776786294",
            appId: "1:357776786294:web:8cb4ec7eabe2895a133057",
            measurementId: "G-0VZ35M4V50"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const CARD_TYPES = { DUKE: 'Duke', ASSASSIN: 'Assassin', CAPTAIN: 'Captain', AMBASSADOR: 'Ambassador', CONTESSA: 'Contessa' };
        const CARD_TRANSLATIONS = {
            [CARD_TYPES.DUKE]: 'ÿßŸÑÿØŸàŸÇ', [CARD_TYPES.ASSASSIN]: 'ÿßŸÑŸÇÿßÿ™ŸÑ',
            [CARD_TYPES.CAPTAIN]: 'ÿßŸÑŸÇÿ®ÿ∑ÿßŸÜ', [CARD_TYPES.AMBASSADOR]: 'ÿßŸÑÿ≥ŸÅŸäÿ±',
            [CARD_TYPES.CONTESSA]: 'ÿßŸÑŸÉŸàŸÜÿ™Ÿäÿ≥ÿß'
        };

        const CARD_IMAGES = {
            [CARD_TYPES.DUKE]: 'https://res.cloudinary.com/do9agtdqi/image/upload/v1754020278/duke_nsvvuc.webp',
            [CARD_TYPES.CONTESSA]: 'https://res.cloudinary.com/do9agtdqi/image/upload/v1754020277/contessa_luhbsn.webp',
            [CARD_TYPES.ASSASSIN]: 'https://res.cloudinary.com/do9agtdqi/image/upload/v1754020272/assasin_muhtsm.webp',
            [CARD_TYPES.CAPTAIN]: 'https://res.cloudinary.com/do9agtdqi/image/upload/v1754020277/captain_xqmeav.webp',
            [CARD_TYPES.AMBASSADOR]: 'https://res.cloudinary.com/do9agtdqi/image/upload/v1754020278/ambassador_k44ipg.webp',
            BACK: 'https://res.cloudinary.com/do9agtdqi/image/upload/v1754020272/back_i5ar84.webp'
        };

        let currentUserId = null, currentGameId = null, gameUnsubscribe = null;
        let scene, camera, renderer, clock;
        let playerObjects = {};
        let cardTextures = {};
        let textureLoader = new THREE.TextureLoader();
        let texturesPreloaded = false;
        let turnTimerInterval = null;
        const TURN_DURATION = 40; 
        
        // --- AVATAR CUSTOMIZATION DATA ---
        const avatarOptions = {
            shirts: ['#ff5733', '#33ff57', '#3357ff', '#ff33a1', '#a133ff', '#ffffff'],
            heads: ['#f2d2b2', '#d1a377', '#a07c5b', '#6e513d', '#3c2a21']
        };
        let currentAvatar = {
            shirt: 0,
            head: 0
        };

        // --- UI ELEMENTS ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const lobbyEl = document.getElementById('lobby');
        const gameIdInput = document.getElementById('game-id-input');
        const playerNameInput = document.getElementById('player-name-input');
        const joinGameBtn = document.getElementById('join-game-btn');
        const createGameBtn = document.getElementById('create-game-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const lobbyError = document.getElementById('lobby-error');
        const lobbyPlayersList = document.getElementById('lobby-players-list');
        const gameIdDisplay = document.getElementById('game-id-display');
        const gameIdIngame = document.getElementById('game-id-ingame');
        const playAgainBtn = document.getElementById('play-again-btn');
        const turnTimerEl = document.getElementById('turn-timer');
        const avatarPreview = document.getElementById('avatar-preview');
        
        // --- AVATAR LOGIC ---
        function generateAvatarSVG({ shirt, head }) {
            const shirtColor = avatarOptions.shirts[shirt];
            const headColor = avatarOptions.heads[head];
            return `
                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <g>
                        <!-- Shirt -->
                        <path d="M 20 90 V 40 C 20 30, 30 30, 40 30 H 60 C 70 30, 80 30, 80 40 V 90 Z" fill="${shirtColor}" />
                        <!-- Head -->
                        <circle cx="50" cy="25" r="15" fill="${headColor}" />
                         <!-- Eyes -->
                        <circle cx="45" cy="25" r="1.5" fill="black" />
                        <circle cx="55" cy="25" r="1.5" fill="black" />
                    </g>
                </svg>
            `;
        }

        function updateAvatarPreview() {
            avatarPreview.innerHTML = generateAvatarSVG(currentAvatar);
        }

        document.getElementById('next-shirt-btn').onclick = () => {
            currentAvatar.shirt = (currentAvatar.shirt + 1) % avatarOptions.shirts.length;
            updateAvatarPreview();
        };
        document.getElementById('prev-shirt-btn').onclick = () => {
            currentAvatar.shirt = (currentAvatar.shirt - 1 + avatarOptions.shirts.length) % avatarOptions.shirts.length;
            updateAvatarPreview();
        };
        document.getElementById('next-head-btn').onclick = () => {
            currentAvatar.head = (currentAvatar.head + 1) % avatarOptions.heads.length;
            updateAvatarPreview();
        };
        document.getElementById('prev-head-btn').onclick = () => {
            currentAvatar.head = (currentAvatar.head - 1 + avatarOptions.heads.length) % avatarOptions.heads.length;
            updateAvatarPreview();
        };

        // Initial Avatar
        updateAvatarPreview();


        // --- AUTH ---
        onAuthStateChanged(auth, user => {
            if (user) {
                currentUserId = user.uid;
                if (texturesPreloaded) {
                    loadingOverlay.classList.add('hidden');
                }
            } else {
                signInAnonymously(auth).catch(() => {});
            }
        });
        
        preloadTextures(() => {
            texturesPreloaded = true;
            if (currentUserId) {
                loadingOverlay.classList.add('hidden');
            }
        });

        // --- LOBBY LOGIC ---
        createGameBtn.addEventListener('click', async () => {
            if (!validateLobbyInput()) return;
            const newGameId = doc(collection(db, 'games')).id.substring(0, 5).toUpperCase();
            await joinGame(newGameId, true);
        });

        joinGameBtn.addEventListener('click', async () => {
            if (!validateLobbyInput()) return;
            const gameId = gameIdInput.value.trim().toUpperCase();
            if (!gameId) {
                lobbyError.textContent = "ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÖÿ≤ ÿßŸÑŸÑÿπÿ®ÿ©.";
                return;
            }
            await joinGame(gameId, false);
        });
        
        startGameBtn.addEventListener('click', async () => {
             if(currentGameId) await startGame(currentGameId);
        });
        
        playAgainBtn.addEventListener('click', () => {
            window.location.reload();
        });

        function validateLobbyInput() {
            if (!currentUserId) { lobbyError.textContent = "ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿµÿßÿØŸÇÿ©ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±..."; return false; }
            if (!playerNameInput.value.trim()) { lobbyError.textContent = "ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖŸÉ."; return false; }
            lobbyError.textContent = '';
            return true;
        }

        async function joinGame(gameId, isCreating) {
            const gameRef = doc(db, 'games', gameId);
            const playerName = playerNameInput.value.trim();
            
            try {
                await runTransaction(db, async (transaction) => {
                    const gameSnap = await transaction.get(gameRef);

                    const playerInitialData = { 
                        name: playerName, 
                        coins: 2, 
                        cards: [], 
                        isAlive: true, 
                        revealedCards: [],
                        avatar: currentAvatar // Save selected avatar
                    };

                    if (isCreating) {
                        if (gameSnap.exists()) throw new Error("Game ID already exists. Try another.");
                        const initialDeck = [];
                        Object.values(CARD_TYPES).forEach(type => { for (let i = 0; i < 3; i++) initialDeck.push(type); });
                        
                        const newGameData = {
                            players: { [currentUserId]: playerInitialData },
                            deck: shuffle(initialDeck),
                            gameState: 'waiting',
                            currentPlayerIndex: 0,
                            turnOrder: [currentUserId],
                            log: [`ÿßŸÑŸÑÿπÿ®ÿ© ${gameId} ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ§Ÿáÿß.`, `${playerName} ÿßŸÜÿ∂ŸÖ ŸÑŸÑÿπÿ®ÿ©.`],
                            createdAt: serverTimestamp(),
                            creatorId: currentUserId,
                            pendingAction: null,
                            playerUpdates: {},
                            turnStartTime: null,
                        };
                        transaction.set(gameRef, newGameData);
                    } else {
                        const gameData = gameSnap.data();
                        if (!gameSnap.exists()) throw new Error("ÿßŸÑŸÑÿπÿ®ÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©.");
                        if (Object.keys(gameData.players).length >= 6 && !gameData.players[currentUserId]) throw new Error("Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ŸÖŸÖÿ™ŸÑÿ¶ÿ©.");
                        if (gameData.gameState !== 'waiting' && !gameData.players[currentUserId]) throw new Error("ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖÿå ÿßŸÑŸÑÿπÿ®ÿ© ÿ®ÿØÿ£ÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ.");
                        
                        if (!gameData.players[currentUserId]) {
                            transaction.update(gameRef, {
                                [`players.${currentUserId}`]: playerInitialData,
                                turnOrder: arrayUnion(currentUserId),
                                log: arrayUnion(`${playerName} ÿßŸÜÿ∂ŸÖ ŸÑŸÑÿπÿ®ÿ©.`)
                            });
                        }
                    }
                });
                currentGameId = gameId;
                listenToLobbyUpdates(gameId);
            } catch (error) {
                lobbyError.textContent = error.message;
            }
        }

        function listenToLobbyUpdates(gameId) {
            const gameRef = doc(db, 'games', gameId);
            if (gameUnsubscribe) gameUnsubscribe();
            
            gameIdDisplay.textContent = `(${gameId})`;
            gameIdIngame.textContent = gameId;

            gameUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) return;
                const gameData = docSnap.data();
                
                if (gameData.gameState === 'waiting') {
                    lobbyPlayersList.innerHTML = '';
                    gameData.turnOrder.forEach(pid => {
                        const player = gameData.players[pid];
                        if (player) {
                            const li = document.createElement('li');
                            li.textContent = player.name + (pid === gameData.creatorId ? ' (ÿßŸÑŸÖÿ∂ŸäŸÅ)' : '');
                            lobbyPlayersList.appendChild(li);
                        }
                    });
                    
                    if (currentUserId === gameData.creatorId && gameData.turnOrder.length >= 2) {
                        startGameBtn.style.display = 'block';
                    } else {
                        startGameBtn.style.display = 'none';
                    }
                } else if (gameData.gameState === 'active' || gameData.gameState === 'finished') {
                    if (lobbyEl.style.display !== 'none') {
                        lobbyEl.style.display = 'none';
                        document.getElementById('ui-overlay').style.display = 'flex';
                        initThreeJS();
                        listenToGameUpdates(gameId); 
                    }
                }
            });
        }

        async function startGame(gameId) {
            const gameRef = doc(db, 'games', gameId);
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) throw new Error("Game not found");

                let gameData = gameSnap.data();
                if (gameData.gameState !== 'waiting') return;

                let { deck, players, turnOrder } = gameData;
                
                turnOrder.forEach(pid => {
                    players[pid].cards.push(deck.pop());
                    players[pid].cards.push(deck.pop());
                });

                transaction.update(gameRef, {
                    players, 
                    deck, 
                    gameState: 'active',
                    turnStartTime: serverTimestamp(),
                    log: arrayUnion("<strong>ÿ®ÿØÿ£ÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ÿ™ŸÖ ÿ™Ÿàÿ≤Ÿäÿπ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™.</strong>")
                });
            });
        }
        
        function listenToGameUpdates(gameId) {
            const gameRef = doc(db, 'games', gameId);
            if (gameUnsubscribe) gameUnsubscribe();
            
            gameUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    if (!scene) return;
                    
                    renderGameState(gameData);
                    
                    const myPlayerData = gameData.players[currentUserId];
                    const myUpdate = gameData.playerUpdates ? gameData.playerUpdates[currentUserId] : null;

                    if (!myPlayerData || !myPlayerData.isAlive) {
                        hideAllModals();
                        checkGameOver(gameData);
                        return;
                    }

                    if (myUpdate) {
                        handlePlayerUpdate(gameData, myUpdate);
                    } else if (gameData.pendingAction) {
                        handlePendingAction(gameData);
                    } else {
                        hideAllModals(); 
                    }
                    
                    checkGameOver(gameData);
                } else {
                    if (gameUnsubscribe) gameUnsubscribe();
                    showGameOverScreen("ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©", "ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ© ŸÖŸÜ ÿßŸÑÿÆÿßÿØŸÖ.");
                    // FIX: Delete game data immediately when document is gone
                    deleteGameData(currentGameId);
                }
            });
        }


        // --- 3D SCENE ---
        function initThreeJS() {
            if (scene) return;
            const container = document.getElementById('game-container');
            clock = new THREE.Clock();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 25, 50); // Adjusted fog for smaller scene

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 22);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.9, 100);
            pointLight.position.set(0, 15, 10);
            pointLight.castShadow = true;
            scene.add(pointLight);

            // FIX: Made the table smaller for mobile view
            const tableGeometry = new THREE.CylinderGeometry(8, 8.5, 0.5, 64);
            const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x3d291a });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.y = -0.25;
            table.receiveShadow = true;
            scene.add(table);
            
            // FIX: Removed the deck mesh from the table
            // const deckGeometry = new THREE.BoxGeometry(2.5, 3.5, 0.5);
            // ... scene.add(deckMesh)

            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();
            animate();
        }
        
        function preloadTextures(callback) {
            const keys = Object.keys(CARD_IMAGES);
            let loaded = 0;
            const total = keys.length;

            if (total === 0) {
                if(callback) callback();
                return;
            }

            const onAssetLoaded = () => {
                if (++loaded === total) {
                    if(callback) callback();
                }
            };

            keys.forEach(key => {
                const url = CARD_IMAGES[key];
                textureLoader.load( url, (texture) => {
                    cardTextures[key] = texture;
                    onAssetLoaded();
                }, undefined, () => {
                    onAssetLoaded();
                });
            });
        }
        
        function createCardMesh(cardType, isFaceUp = false) {
             const cardGeometry = new THREE.BoxGeometry(3.2, 4.4, 0.1);
             const materials = [
                 new THREE.MeshStandardMaterial({ color: 0x111111 }), new THREE.MeshStandardMaterial({ color: 0x111111 }),
                 new THREE.MeshStandardMaterial({ color: 0x111111 }), new THREE.MeshStandardMaterial({ color: 0x111111 }),
                 new THREE.MeshStandardMaterial({ map: isFaceUp && cardTextures[cardType] ? cardTextures[cardType] : cardTextures.BACK }),
                 new THREE.MeshStandardMaterial({ map: cardTextures.BACK })
             ];
             const cardMesh = new THREE.Mesh(cardGeometry, materials);
             cardMesh.castShadow = true;
             cardMesh.userData = { type: cardType, isFaceUp: isFaceUp };
             return cardMesh;
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            if (window.innerWidth < 768) {
                // FIX: Adjusted mobile camera for smaller table
                camera.fov = 70;
                camera.position.set(0, 16, 15); 
            } else {
                camera.fov = 50;
                camera.position.set(0, 15, 22);
            }
            camera.lookAt(0,0,0);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(renderer) renderer.render(scene, camera);
        }
        
        // --- GAME STATE RENDERING ---
        function renderGameState(gameData) {
            if (!scene) return;
        
            const { players, turnOrder, currentPlayerIndex } = gameData;
            const myIndex = turnOrder.indexOf(currentUserId);
            
            document.getElementById('player-infos').innerHTML = '';
        
            turnOrder.forEach((pid, index) => {
                const player = players[pid];
                if (!player) return;
        
                if (!playerObjects[pid]) {
                    playerObjects[pid] = { cards: [], revealedCards: [], infoDiv: null };
                }
        
                const relativeIndex = (index - myIndex + turnOrder.length) % turnOrder.length;
                
                let x, z, yPos, angle;
                let isMe = (relativeIndex === 0);

                // FIX: Reworked all positions for the smaller table
                if (window.innerWidth < 768) {
                    const radius = isMe ? 11 : 12;
                    yPos = isMe ? 2.5 : 4;
                    angle = (relativeIndex / turnOrder.length) * Math.PI * 2;
                    x = Math.sin(angle) * radius;
                    z = Math.cos(angle) * radius;
                } else {
                    const radius = isMe ? 12 : 13;
                    yPos = isMe ? 3 : 4;
                    angle = (relativeIndex / turnOrder.length) * Math.PI * 2;
                    x = Math.sin(angle) * radius;
                    z = Math.cos(angle) * radius;
                }
        
                updateCardGroup(playerObjects[pid].cards, player.cards, pid, 'active', { x, y: yPos, z }, angle, isMe);
                updateCardGroup(playerObjects[pid].revealedCards, player.revealedCards, pid, 'revealed', { x, y: yPos, z }, angle, isMe);
        
                const screenPos = toScreenPosition(new THREE.Vector3(x, yPos + 4.5, z), camera);
                let infoDiv = playerObjects[pid].infoDiv;
                if (!infoDiv) {
                    infoDiv = document.createElement('div');
                    document.getElementById('player-infos').appendChild(infoDiv);
                    playerObjects[pid].infoDiv = infoDiv;
                }
        
                infoDiv.className = 'player-info ui-element';
                if (!player.isAlive) infoDiv.classList.add('eliminated');
                if (turnOrder[currentPlayerIndex] === pid && player.isAlive) {
                    infoDiv.classList.add('current-turn');
                }
                infoDiv.style.left = `${screenPos.x}px`;
                infoDiv.style.top = `${screenPos.y}px`;

                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'avatar';
                if (player.avatar) {
                    avatarDiv.innerHTML = generateAvatarSVG(player.avatar);
                } else {
                    avatarDiv.textContent = player.name.charAt(0);
                }

                infoDiv.innerHTML = ''; // Clear previous content
                infoDiv.appendChild(avatarDiv);
                infoDiv.innerHTML += `<div class="font-bold">${player.name}</div><div>üí∞ ${player.coins}</div>`;
            });
        
            updateActionButtons(gameData);
            updateMessageLog(gameData);
            updateTurnTimer(gameData);
        }
        
        function updateCardGroup(meshArray, dataArray, pid, cardGroupType, basePos, angle, isMe) {
            while (meshArray.length > dataArray.length) {
                scene.remove(meshArray.pop());
            }
        
            while (meshArray.length < dataArray.length) {
                const newMesh = createCardMesh(null, cardGroupType === 'revealed');
                newMesh.position.set(basePos.x, basePos.y, basePos.z);
                scene.add(newMesh);
                meshArray.push(newMesh);
            }
        
            dataArray.forEach((cardType, i) => {
                const cardMesh = meshArray[i];
                const isFaceUp = (isMe && cardGroupType === 'active') || cardGroupType === 'revealed';
        
                if (cardMesh.userData.type !== cardType || cardMesh.userData.isFaceUp !== isFaceUp) {
                    cardMesh.material[4].map = isFaceUp ? cardTextures[cardType] : cardTextures.BACK;
                    cardMesh.material[4].needsUpdate = true;
                    cardMesh.userData.type = cardType;
                    cardMesh.userData.isFaceUp = isFaceUp;
                }
        
                let targetPos, targetRot;
                const cardOffsetMultiplier = 3.8;
                
                if (cardGroupType === 'active') {
                    const cardOffset = (i - (dataArray.length - 1) / 2) * cardOffsetMultiplier;
                    if (isMe) {
                        targetPos = new THREE.Vector3(cardOffset, basePos.y, basePos.z);
                        targetRot = new THREE.Euler(-Math.PI / 8, 0, 0);
                    } else {
                        targetPos = new THREE.Vector3(basePos.x, basePos.y, basePos.z);
                        const tempLookAt = cardMesh.clone();
                        tempLookAt.position.copy(targetPos);
                        tempLookAt.lookAt(camera.position);
                        targetRot = tempLookAt.rotation.clone();
                         // Add slight offset for multiple cards
                        const offsetAngle = angle - Math.PI / 2;
                        targetPos.x += Math.sin(offsetAngle) * cardOffset * 0.3;
                        targetPos.z += Math.cos(offsetAngle) * cardOffset * 0.3;
                    }
                } else { 
                    const tableRadius = isMe ? 5 : 4.5; // Smaller radius for revealed cards
                    const tablePos = new THREE.Vector3(basePos.x, 0.2, basePos.z).normalize().multiplyScalar(tableRadius);
                    const cardOffset = (i - (dataArray.length - 1) / 2) * cardOffsetMultiplier;
                    
                    const perpendicularAngle = angle - Math.PI / 2;
                    const offsetVec = new THREE.Vector3(Math.sin(perpendicularAngle), 0, Math.cos(perpendicularAngle)).multiplyScalar(cardOffset);

                    targetPos = tablePos.add(offsetVec);
                    targetPos.y = 0.3;
                    targetRot = new THREE.Euler(-Math.PI / 2.3, 0, -angle);
                }
        
                gsap.to(cardMesh.position, { duration: 0.5, x: targetPos.x, y: targetPos.y, z: targetPos.z });
                gsap.to(cardMesh.rotation, { duration: 0.5, x: targetRot.x, y: targetRot.y, z: targetRot.z });
            });
        }
        
        function updateActionButtons(gameData) {
            const actionsContainer = document.getElementById('action-buttons');
            actionsContainer.innerHTML = '';
            
            const myTurn = gameData.turnOrder[gameData.currentPlayerIndex] === currentUserId;
            const me = gameData.players[currentUserId];
            
            // FIX: Simplified the logic to ensure buttons always show on your turn if no other action is pending.
            const shouldShow = gameData.gameState === 'active' && myTurn && me?.isAlive && !gameData.pendingAction && (!gameData.playerUpdates || !gameData.playerUpdates[currentUserId]);

            if (!shouldShow) {
                 if(myTurn) {
                    actionsContainer.innerHTML = `<p class="text-gray-400 animate-pulse">ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ÿ±ÿØŸàÿØ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ...</p>`;
                 }
                 return;
            }

            const myCoins = me.coins;
            
            if (myCoins >= 10) {
                addActionBtn('ÿßŸÜŸÇŸÑÿßÿ® (ÿ•ÿ¨ÿ®ÿßÿ±Ÿä)', () => showTargetSelection('Coup'));
                return;
            }
            
            addActionBtn('ÿØÿÆŸÑ (1üí∞)', () => initiateAction('Income'));
            addActionBtn('ŸÖÿ≥ÿßÿπÿØÿ© ÿ£ÿ¨ŸÜÿ®Ÿäÿ© (2üí∞)', () => initiateAction('Foreign Aid'));
            if (myCoins >= 7) addActionBtn('ÿßŸÜŸÇŸÑÿßÿ® (7üí∞)', () => showTargetSelection('Coup'));
            addActionBtn('ÿßÿ∫ÿ™ŸäÿßŸÑ (3üí∞)', () => showTargetSelection('Assassinate'), myCoins < 3);
            addActionBtn('ÿ∂ÿ±ÿßÿ¶ÿ® (ÿßŸÑÿØŸàŸÇ)', () => initiateAction('Tax'));
            addActionBtn('ÿ≥ÿ±ŸÇÿ© (ÿßŸÑŸÇÿ®ÿ∑ÿßŸÜ)', () => showTargetSelection('Steal'));
            addActionBtn('ÿ™ÿ®ÿØŸäŸÑ (ÿßŸÑÿ≥ŸÅŸäÿ±)', () => initiateAction('Exchange'));
        }
        
        function updateMessageLog(gameData) {
            // Logic remains but element is hidden by CSS
        }

        // --- CORE GAME FLOW & TIMER ---
        async function forceEndTurn() {
            const gameRef = doc(db, 'games', currentGameId);
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) return;
                const gameData = gameSnap.data();
                
                if (gameData.turnOrder[gameData.currentPlayerIndex] !== currentUserId || gameData.pendingAction) {
                    return;
                }

                const updates = {};
                updates[`players.${currentUserId}.coins`] = gameData.players[currentUserId].coins + 1;
                updates.log = arrayUnion(`<strong>${gameData.players[currentUserId].name}</strong> ŸÜŸÅÿ∞ ÿßŸÑŸàŸÇÿ™ Ÿàÿ£ÿÆÿ∞ 'ÿØÿÆŸÑ' ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.`);
                updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                updates.turnStartTime = serverTimestamp();
                transaction.update(gameRef, updates);
            });
        }

        function updateTurnTimer(gameData) {
            if (turnTimerInterval) clearInterval(turnTimerInterval);
            
            const isMyTurn = gameData.turnOrder[gameData.currentPlayerIndex] === currentUserId;
            const noPendingActions = !gameData.pendingAction && (!gameData.playerUpdates || !gameData.playerUpdates[currentUserId]);

            if (gameData.gameState === 'active' && isMyTurn && noPendingActions && gameData.turnStartTime) {
                turnTimerEl.style.display = 'block';
                const startTime = gameData.turnStartTime.toDate();
                
                turnTimerInterval = setInterval(() => {
                    const now = new Date();
                    const elapsed = Math.floor((now - startTime) / 1000);
                    const remaining = TURN_DURATION - elapsed;
                    
                    if (remaining <= 0) {
                        turnTimerEl.textContent = '0';
                        clearInterval(turnTimerInterval);
                        forceEndTurn();
                    } else {
                        turnTimerEl.textContent = remaining;
                    }
                }, 1000);
            } else {
                turnTimerEl.style.display = 'none';
            }
        }
        
        async function initiateAction(actionType, targetId = null) {
            const gameRef = doc(db, 'games', currentGameId);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists()) return;
            const gameData = gameSnap.data();
            const actorName = gameData.players[currentUserId].name;
            
            let logMessage = `<strong>${actorName}</strong> ŸäŸÜŸàŸä ÿßŸÑŸÇŸäÿßŸÖ ÿ®ŸÄ: <strong>${actionType}</strong>`;
            if (targetId) logMessage += ` ÿ∂ÿØ <strong>${gameData.players[targetId].name}</strong>.`;
            
            const updates = { log: arrayUnion(logMessage) };

            const unchallengable = ['Income', 'Coup'];
            if (unchallengable.includes(actionType)) {
                if (actionType === 'Coup') {
                    const target = gameData.players[targetId];
                    if (target && target.coins >= 10) {
                        updates[`players.${currentUserId}.coins`] = gameData.players[currentUserId].coins - 7;
                        updates[`players.${targetId}.coins`] = 0;
                        updates.log = arrayUnion(`<strong>${actorName}</strong> ÿßŸÜŸÇŸÑÿ® ÿπŸÑŸâ <strong>${target.name}</strong>ÿå ÿßŸÑÿ∞Ÿä ÿÆÿ≥ÿ± ŸÉŸÑ ÿπŸÖŸÑÿßÿ™Ÿá ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ŸÜŸÅŸàÿ∞Ÿá.`);
                        updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                        updates.turnStartTime = serverTimestamp();
                        await updateDoc(gameRef, updates);
                        return;
                    }
                }
                
                Object.assign(updates, getActionEffects(gameData, { actorId: currentUserId, actionType, targetId }));
                if (actionType !== 'Coup') {
                    updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                    updates.turnStartTime = serverTimestamp();
                }
            } else {
                updates.pendingAction = {
                    type: 'ACTION',
                    actorId: currentUserId,
                    actionType: actionType,
                    targetId: targetId,
                    responses: {},
                };
            }
            await updateDoc(gameRef, updates);
        }
        
        function handlePendingAction(gameData) {
            // This function's logic remains the same
        }

        async function respondToAction(responseType, blockType = null) {
            // This function's logic remains the same
        }
        
        async function resolveChallenge(transaction, gameData, action, challengerId) {
            // This function's logic remains the same
        }

        async function resolveBlockChallenge(transaction, gameData, action, challengerId) {
            // This function's logic remains the same
        }

        function getActionEffects(gameData, action) {
            // This function's logic remains the same
        }

        // --- PLAYER UPDATE HANDLERS ---
        function handlePlayerUpdate(gameData, update) {
            hideAllModals();
            if (update.type === 'mustReveal') {
                showRevealCardModal(gameData, update.reason);
            } else if (update.type === 'exchange') {
                showExchangeModal(gameData, update.cards);
            }
        }

        async function revealCard(cardIndex) {
            // This function's logic remains the same
        }
        
        async function confirmExchange(keptCards, returnedCards) {
             // This function's logic remains the same
        }
        
        function showRevealCardModal(gameData, reason) {
            // This function's logic remains the same
        }

        function showExchangeModal(gameData, drawnCards) {
            // This function's logic remains the same
        }

        // --- UTILITY & UI FUNCTIONS ---
        function addActionBtn(text, onClick, disabled = false) {
            // This function's logic remains the same
        }
        
        function createModalBtn(text, onClick) {
            // This function's logic remains the same
        }

        function showTargetSelection(actionType) {
            // This function's logic remains the same
        }

        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if(modal) modal.style.display = 'none';
        }

        function hideAllModals() {
            document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
        }

        function getNextPlayerIndex(gameData) {
            let nextIndex = gameData.currentPlayerIndex;
            let count = 0;
            do {
                nextIndex = (nextIndex + 1) % gameData.turnOrder.length;
                count++;
            } while(!gameData.players[gameData.turnOrder[nextIndex]].isAlive && count < gameData.turnOrder.length * 2);
            return nextIndex;
        }
        
        async function checkGameOver(gameData) {
            if (gameData.gameState !== 'active') return;
            const alivePlayers = gameData.turnOrder.filter(pid => gameData.players[pid]?.isAlive);
            if (alivePlayers.length <= 1) {
                if (gameUnsubscribe) gameUnsubscribe(); gameUnsubscribe = null;
                if (turnTimerInterval) clearInterval(turnTimerInterval);

                const winnerId = alivePlayers.length === 1 ? alivePlayers[0] : null;
                const winnerName = winnerId ? gameData.players[winnerId].name : "ŸÑÿß ÿ£ÿ≠ÿØ";
                
                await updateDoc(doc(db, 'games', currentGameId), { gameState: 'finished', log: arrayUnion(`ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ÿßŸÑŸÅÿßÿ¶ÿ≤ ŸáŸà <strong>${winnerName}</strong>.`) });
                showGameOverScreen(`ÿßŸÑŸÅÿßÿ¶ÿ≤ ŸáŸà ${winnerName}!`, "ÿ≥Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ®ŸäÿßŸÜÿßÿ™ Ÿáÿ∞Ÿá ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿ¢ŸÜ.");
                
                // FIX: Delete game data immediately
                deleteGameData(currentGameId);
            }
        }
        
        function showGameOverScreen(winnerText, cleanupText) {
             document.getElementById('winner-text').textContent = winnerText;
             document.getElementById('cleanup-text').textContent = cleanupText;
             document.getElementById('game-over-screen').style.display = 'flex';
        }

        async function deleteGameData(gameId) {
            if (!gameId) return;
            try {
                // To prevent race conditions, we check if we are the creator before deleting
                const gameRef = doc(db, 'games', gameId);
                const gameSnap = await getDoc(gameRef);
                if (gameSnap.exists() && gameSnap.data().creatorId === currentUserId) {
                    await deleteDoc(gameRef);
                }
            } catch (error) {
                // Errors are intentionally silenced
            }
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function toScreenPosition(vector, camera) {
            const width = window.innerWidth, height = window.innerHeight;
            const widthHalf = width / 2, heightHalf = height / 2;
            vector.project(camera);
            vector.x = (vector.x * widthHalf) + widthHalf;
            vector.y = -(vector.y * heightHalf) + heightHalf;
            return { x: vector.x, y: vector.y };
        }
        
        // Re-pasting functions that might have been removed by mistake in previous edits
        // They are mostly unchanged but included for completeness.
        
        // Handle Pending Action
        handlePendingAction = function(gameData) {
            const { pendingAction, players } = gameData;
            if (!pendingAction) { hideModal('interaction-modal'); return; }

            const me = players[currentUserId];
            const modal = document.getElementById('interaction-modal');
            const buttonsContainer = document.getElementById('modal-buttons');
            buttonsContainer.innerHTML = '';

            if (pendingAction.type === 'ACTION' && pendingAction.actorId !== currentUserId && me.isAlive && !pendingAction.responses[currentUserId]) {
                const actorName = players[pendingAction.actorId].name;
                document.getElementById('modal-title').textContent = `ÿ≠ÿ±ŸÉÿ© ŸÖŸÜ ${actorName}!`;
                document.getElementById('modal-text').textContent = `${actorName} ŸäŸÇŸàŸÖ ÿ®ŸÄ ${CARD_TRANSLATIONS[pendingAction.actionType] || pendingAction.actionType}.`;

                buttonsContainer.appendChild(createModalBtn('ÿ™ÿ≠ÿØŸä!', () => respondToAction('challenge')));

                const amITarget = pendingAction.targetId === currentUserId;
                if (pendingAction.actionType === 'Foreign Aid') {
                    buttonsContainer.appendChild(createModalBtn('ÿ£ŸÖŸÜÿπ (ÿ®ÿßŸÑÿØŸàŸÇ)', () => respondToAction('block', 'BlockForeignAid')));
                }
                if (amITarget && pendingAction.actionType === 'Steal') {
                    buttonsContainer.appendChild(createModalBtn('ÿ£ŸÖŸÜÿπ (ÿ®ÿßŸÑŸÇÿ®ÿ∑ÿßŸÜ/ÿßŸÑÿ≥ŸÅŸäÿ±)', () => respondToAction('block', 'BlockSteal')));
                }
                if (amITarget && pendingAction.actionType === 'Assassinate') {
                    buttonsContainer.appendChild(createModalBtn('ÿ£ŸÖŸÜÿπ (ÿ®ÿßŸÑŸÉŸàŸÜÿ™Ÿäÿ≥ÿß)', () => respondToAction('block', 'BlockAssassination')));
                }

                buttonsContainer.appendChild(createModalBtn('ÿ™ÿ¨ÿßŸáŸÑ', () => respondToAction('pass')));
                modal.style.display = 'flex';
                return;
            }

            if (pendingAction.type === 'BLOCK' && pendingAction.actorId === currentUserId && me.isAlive && !pendingAction.responses[currentUserId]) {
                const blockerName = players[pendingAction.blockerId].name;
                document.getElementById('modal-title').textContent = `${blockerName} ŸäŸÖŸÜÿπ ÿ≠ÿ±ŸÉÿ™ŸÉ!`;
                document.getElementById('modal-text').textContent = `${blockerName} ŸäÿØÿπŸä ÿ£ŸÜ ŸÑÿØŸäŸá ${CARD_TRANSLATIONS[pendingAction.blockCard]} ŸÑŸÖŸÜÿπ ${CARD_TRANSLATIONS[pendingAction.actionType] || pendingAction.actionType}.`;
                
                buttonsContainer.appendChild(createModalBtn('ÿ™ÿ≠ÿØŸâ ÿßŸÑŸÖŸÜÿπ!', () => respondToAction('challenge_block')));
                buttonsContainer.appendChild(createModalBtn('ÿßŸÇÿ®ŸÑ ÿßŸÑŸÖŸÜÿπ', () => respondToAction('pass_block')));
                modal.style.display = 'flex';
                return;
            }

            hideModal('interaction-modal');
        }

        // Respond To Action
        respondToAction = async function(responseType, blockType = null) {
            hideModal('interaction-modal');
            const gameRef = doc(db, 'games', currentGameId);
            
            await runTransaction(db, async (transaction) => {
                const gameSnap = await transaction.get(gameRef);
                if (!gameSnap.exists()) return;
                const gameData = gameSnap.data();
                let { pendingAction, players, turnOrder } = gameData;
                
                if (!pendingAction) return;

                const updates = {};
                const me = players[currentUserId];

                if (pendingAction.type === 'ACTION') {
                    if (responseType === 'pass') {
                        updates[`pendingAction.responses.${currentUserId}`] = 'pass';
                        const aliveOpponents = turnOrder.filter(pid => players[pid].isAlive && pid !== pendingAction.actorId);
                        const allPassed = aliveOpponents.every(pid => (pendingAction.responses[pid] === 'pass' || pid === currentUserId));
                        if (allPassed) {
                            updates.log = arrayUnion(`ÿßŸÑÿ¨ŸÖŸäÿπ ÿ™ÿ¨ÿßŸáŸÑ. <strong>${players[pendingAction.actorId].name}</strong> ŸÜÿ¨ÿ≠ ŸÅŸä ÿ≠ÿ±ŸÉÿ© <strong>${CARD_TRANSLATIONS[pendingAction.actionType] || pendingAction.actionType}</strong>.`);
                            Object.assign(updates, getActionEffects(gameData, pendingAction));
                            
                            if (pendingAction.actionType === 'Foreign Aid') {
                                updates.log = arrayUnion(`<strong>${players[pendingAction.actorId].name}</strong> ŸäŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.`);
                                updates.turnStartTime = serverTimestamp();
                            } else if (pendingAction.actionType !== 'Exchange' && pendingAction.actionType !== 'Assassinate') {
                                updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                                updates.turnStartTime = serverTimestamp();
                            }
                            updates.pendingAction = null;
                        }
                    } else if (responseType === 'challenge') {
                        await resolveChallenge(transaction, gameData, pendingAction, currentUserId);
                        return;
                    } else if (responseType === 'block') {
                        const blockCardMap = { 'BlockForeignAid': CARD_TYPES.DUKE, 'BlockAssassination': CARD_TYPES.CONTESSA, 'BlockSteal': [CARD_TYPES.CAPTAIN, CARD_TYPES.AMBASSADOR] };
                        const blockCard = Array.isArray(blockCardMap[blockType]) ? (me.cards.includes(CARD_TYPES.CAPTAIN) ? CARD_TYPES.CAPTAIN : CARD_TYPES.AMBASSADOR) : blockCardMap[blockType];
                        
                        updates.pendingAction = {
                            type: 'BLOCK',
                            actorId: pendingAction.actorId, actionType: pendingAction.actionType,
                            targetId: pendingAction.targetId, blockerId: currentUserId,
                            blockCard: blockCard, responses: {}
                        };
                        updates.log = arrayUnion(`<strong>${me.name}</strong> ŸäŸÖŸÜÿπ ÿßŸÑÿ≠ÿ±ŸÉÿ©!`);
                    }
                }
                else if (pendingAction.type === 'BLOCK') {
                    if (responseType === 'challenge_block') {
                        await resolveBlockChallenge(transaction, gameData, pendingAction, currentUserId);
                        return;
                    } else if (responseType === 'pass_block') {
                        updates.log = arrayUnion(`<strong>${me.name}</strong> ŸÇÿ®ŸÑ ÿßŸÑŸÖŸÜÿπ. ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÅÿ¥ŸÑÿ™.`);
                        updates.pendingAction = null;
                        updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                        updates.turnStartTime = serverTimestamp();
                    }
                }
                
                transaction.update(gameRef, updates);
            });
        }

        // Resolve Challenge
        resolveChallenge = async function(transaction, gameData, action, challengerId) {
            const { players, deck } = gameData;
            const actor = players[action.actorId];
            const challenger = players[challengerId];
            const updates = {};
            const claimCard = { 'Tax': CARD_TYPES.DUKE, 'Assassinate': CARD_TYPES.ASSASSIN, 'Steal': CARD_TYPES.CAPTAIN, 'Exchange': CARD_TYPES.AMBASSADOR }[action.actionType];

            if (actor.cards.includes(claimCard)) { 
                updates.log = arrayUnion(`ÿ™ÿ≠ÿØŸä ŸÅÿßÿ¥ŸÑ! <strong>${actor.name}</strong> ŸÉÿßŸÜ ÿµÿßÿØŸÇŸãÿß. <strong>${challenger.name}</strong> ŸäÿÆÿ≥ÿ± ŸÜŸÅŸàÿ∞Ÿãÿß.`);
                updates[`playerUpdates.${challengerId}`] = { type: 'mustReveal', reason: 'ÿÆÿ≥ÿ±ÿ™ ÿßŸÑÿ™ÿ≠ÿØŸä.' };
                
                const newDeck = [...deck];
                const cardIndex = actor.cards.indexOf(claimCard);
                const revealedCard = actor.cards.splice(cardIndex, 1)[0];
                actor.cards.push(newDeck.pop());
                newDeck.push(revealedCard);
                updates[`players.${action.actorId}.cards`] = actor.cards;
                updates.deck = shuffle(newDeck);
                updates.log = arrayUnion(`${actor.name} ÿ£ÿ∏Ÿáÿ± ÿ®ÿ∑ÿßŸÇÿ© ${CARD_TRANSLATIONS[revealedCard]} Ÿàÿ≥ÿ≠ÿ® Ÿàÿßÿ≠ÿØÿ© ÿ¨ÿØŸäÿØÿ©.`);

                Object.assign(updates, getActionEffects({ ...gameData, deck: newDeck, players }, action));
                updates.pendingAction = null; 

            } else { 
                updates.log = arrayUnion(`ÿ™ÿ≠ÿØŸä ŸÜÿßÿ¨ÿ≠! <strong>${actor.name}</strong> ŸÉÿßŸÜ ŸäŸÉÿ∞ÿ® ŸàŸäÿÆÿ≥ÿ± ŸÜŸÅŸàÿ∞Ÿãÿß.`);
                updates[`playerUpdates.${action.actorId}`] = { type: 'mustReveal', reason: 'ÿ™ŸÖ ŸÉÿ¥ŸÅ ŸÉÿ∞ÿ®ÿ™ŸÉ.' };
                updates.pendingAction = null; 
                updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                updates.turnStartTime = serverTimestamp();
            }
            transaction.update(doc(db, 'games', currentGameId), updates);
        }

        // Resolve Block Challenge
        resolveBlockChallenge = async function(transaction, gameData, action, challengerId) {
            const { players, deck } = gameData;
            const blocker = players[action.blockerId];
            const challenger = players[challengerId]; 
            const updates = {};
            const blockClaim = action.blockCard;

            if (blocker.cards.includes(blockClaim)) { 
                updates.log = arrayUnion(`ÿ™ÿ≠ÿØŸä ŸÅÿßÿ¥ŸÑ! <strong>${blocker.name}</strong> ŸÉÿßŸÜ ÿµÿßÿØŸÇŸãÿß. <strong>${challenger.name}</strong> ŸäÿÆÿ≥ÿ± ŸÜŸÅŸàÿ∞Ÿãÿß.`);
                updates[`playerUpdates.${challengerId}`] = { type: 'mustReveal', reason: 'ÿÆÿ≥ÿ±ÿ™ ÿ™ÿ≠ÿØŸä ÿßŸÑŸÖŸÜÿπ.' };
                
                const newDeck = [...deck];
                const cardIndex = blocker.cards.indexOf(blockClaim);
                const revealedCard = blocker.cards.splice(cardIndex, 1)[0];
                blocker.cards.push(newDeck.pop());
                newDeck.push(revealedCard);
                updates[`players.${action.blockerId}.cards`] = blocker.cards;
                updates.deck = shuffle(newDeck);
                updates.log = arrayUnion(`${blocker.name} ÿ£ÿ∏Ÿáÿ± ÿ®ÿ∑ÿßŸÇÿ© ${CARD_TRANSLATIONS[revealedCard]} Ÿàÿ≥ÿ≠ÿ® Ÿàÿßÿ≠ÿØÿ© ÿ¨ÿØŸäÿØÿ©.`);
                
                updates.pendingAction = null;
                updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                updates.turnStartTime = serverTimestamp();
            } else { 
                updates.log = arrayUnion(`ÿ™ÿ≠ÿØŸä ŸÜÿßÿ¨ÿ≠! <strong>${blocker.name}</strong> ŸÉÿßŸÜ ŸäŸÉÿ∞ÿ® ŸàŸäÿÆÿ≥ÿ± ŸÜŸÅŸàÿ∞Ÿãÿß.`);
                updates[`playerUpdates.${action.blockerId}`] = { type: 'mustReveal', reason: 'ÿ™ŸÖ ŸÉÿ¥ŸÅ ŸÉÿ∞ÿ®ÿ© ÿßŸÑŸÖŸÜÿπ.' };
                
                Object.assign(updates, getActionEffects(gameData, action));
                updates.pendingAction = null; 
            }
            transaction.update(doc(db, 'games', currentGameId), updates);
        }

        // Get Action Effects
        getActionEffects = function(gameData, action) {
            const { actorId, actionType, targetId } = action;
            const updates = {};
            const actorCoins = gameData.players[actorId].coins;
            
            switch (actionType) {
                case 'Income': updates[`players.${actorId}.coins`] = actorCoins + 1; break;
                case 'Foreign Aid': updates[`players.${actorId}.coins`] = actorCoins + 2; break;
                case 'Tax': updates[`players.${actorId}.coins`] = actorCoins + 3; break;
                case 'Coup':
                    updates[`players.${actorId}.coins`] = actorCoins - 7;
                    updates[`playerUpdates.${targetId}`] = { type: 'mustReveal', reason: 'ÿ™ŸÖ ÿßŸÑÿßŸÜŸÇŸÑÿßÿ® ÿπŸÑŸäŸÉ!' };
                    break;
                case 'Steal':
                    const targetCoins = gameData.players[targetId].coins;
                    const stolenAmount = Math.min(2, targetCoins);
                    updates[`players.${actorId}.coins`] = actorCoins + stolenAmount;
                    updates[`players.${targetId}.coins`] = targetCoins - stolenAmount;
                    break;
                case 'Assassinate':
                    updates[`players.${actorId}.coins`] = actorCoins - 3;
                    updates[`playerUpdates.${targetId}`] = { type: 'mustReveal', reason: 'ÿ™ŸÖ ÿßÿ∫ÿ™ŸäÿßŸÑŸÉ!' };
                    break;
                case 'Exchange':
                    const newDeck = [...gameData.deck];
                    const drawnCards = [newDeck.pop(), newDeck.pop()];
                    updates[`playerUpdates.${actorId}`] = { type: 'exchange', cards: drawnCards };
                    updates.deck = newDeck;
                    break;
            }
            return updates;
        }

        // Reveal Card
        revealCard = async function(cardIndex) {
            hideModal('reveal-card-modal');
            await runTransaction(db, async (transaction) => {
                const gameRef = doc(db, 'games', currentGameId);
                const gameSnap = await transaction.get(gameRef);
                const gameData = gameSnap.data();
                const player = gameData.players[currentUserId];

                const cardToReveal = player.cards.splice(cardIndex, 1)[0];
                player.revealedCards.push(cardToReveal);

                const updates = {};
                
                let logMessage = `<strong>${player.name}</strong> ŸäŸÉÿ¥ŸÅ ŸàŸäÿÆÿ≥ÿ± <strong>${CARD_TRANSLATIONS[cardToReveal]}</strong>.`;
                if (player.cards.length === 0) {
                    player.isAlive = false;
                    logMessage += ` <strong>${player.name}</strong> ÿ™ŸÖ ÿ•ŸÇÿµÿßÿ§Ÿá!`;
                }

                updates[`players.${currentUserId}`] = player;
                updates[`playerUpdates.${currentUserId}`] = null;
                
                // Check if the game should advance the turn
                const updateCausedByChallenge = gameData.playerUpdates[currentUserId] && gameData.playerUpdates[currentUserId].reason;
                if (!updateCausedByChallenge) {
                    updates.currentPlayerIndex = getNextPlayerIndex(gameData);
                    updates.turnStartTime = serverTimestamp();
                }

                updates.log = arrayUnion(logMessage);
                transaction.update(gameRef, updates);
            });
        }

        // Confirm Exchange
        confirmExchange = async function(keptCards, returnedCards) {
             hideModal('exchange-modal');
             await runTransaction(db, async (transaction) => {
                 const gameRef = doc(db, 'games', currentGameId);
                 const gameData = await transaction.get(gameRef).then(snap => snap.data());
                 
                 const updates = {
                     [`players.${currentUserId}.cards`]: keptCards,
                     [`playerUpdates.${currentUserId}`]: null,
                     deck: shuffle([...gameData.deck, ...returnedCards]),
                     log: arrayUnion(`<strong>${gameData.players[currentUserId].name}</strong> ŸÇÿßŸÖ ÿ®ÿ™ÿ®ÿØŸäŸÑ ÿ®ÿ∑ÿßŸÇÿßÿ™Ÿá.`),
                     currentPlayerIndex: getNextPlayerIndex(gameData),
                     turnStartTime: serverTimestamp()
                 };
                 transaction.update(gameRef, updates);
             });
        }

        // Show Reveal Card Modal
        showRevealCardModal = function(gameData, reason) {
            const modal = document.getElementById('reveal-card-modal');
            const container = document.getElementById('reveal-cards-container');
            const myData = gameData.players[currentUserId];
            
            document.getElementById('reveal-title').textContent = reason;
            container.innerHTML = '';

            myData.cards.forEach((cardType, index) => {
                const img = document.createElement('img');
                img.src = CARD_IMAGES[cardType];
                img.onclick = () => revealCard(index);
                container.appendChild(img);
            });
            modal.style.display = 'flex';
        }

        // Show Exchange Modal
        showExchangeModal = function(gameData, drawnCards) {
            const modal = document.getElementById('exchange-modal');
            const container = document.getElementById('exchange-cards-container');
            const myData = gameData.players[currentUserId];
            const confirmBtn = document.getElementById('confirm-exchange-btn');
            
            const allCards = [...myData.cards, ...drawnCards];
            let selectedImages = [];
            
            container.innerHTML = '';
            const numToKeep = myData.cards.length;
            document.getElementById('exchange-text').textContent = `ŸÑÿØŸäŸÉ ${allCards.length} ÿ®ÿ∑ÿßŸÇÿßÿ™. ÿßÿÆÿ™ÿ± ${numToKeep} ŸÑŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏ ÿ®Ÿáÿß.`;
            
            allCards.forEach((cardType) => {
                const img = document.createElement('img');
                img.src = CARD_IMAGES[cardType];
                img.dataset.cardType = cardType;

                img.onclick = () => {
                    if (img.classList.contains('selected')) {
                        img.classList.remove('selected');
                        selectedImages.splice(selectedImages.indexOf(img), 1);
                    } else if (selectedImages.length < numToKeep) {
                        img.classList.add('selected');
                        selectedImages.push(img);
                    }
                    confirmBtn.disabled = selectedImages.length !== numToKeep;
                };
                container.appendChild(img);
            });

            confirmBtn.onclick = () => {
                const keptCards = selectedImages.map(img => img.dataset.cardType);
                const returnedCards = [...allCards];
                keptCards.forEach(keptType => {
                    const indexToRemove = returnedCards.indexOf(keptType);
                    if (indexToRemove > -1) returnedCards.splice(indexToRemove, 1);
                });
                confirmExchange(keptCards, returnedCards);
            };
            modal.style.display = 'flex';
        }

        // Add Action Button
        addActionBtn = function(text, onClick, disabled = false) {
            const btn = document.createElement('button');
            btn.className = 'action-btn';
            btn.textContent = text;
            btn.disabled = disabled;
            btn.onclick = onClick;
            document.getElementById('action-buttons').appendChild(btn);
        }
        
        // Create Modal Button
        createModalBtn = function(text, onClick) {
            const btn = document.createElement('button');
            btn.className = 'action-btn';
            btn.textContent = text;
            btn.onclick = onClick;
            return btn;
        }

        // Show Target Selection
        showTargetSelection = function(actionType) {
            const modal = document.getElementById('target-selection-modal');
            const list = document.getElementById('target-player-list');
            list.innerHTML = '';
            
            getDoc(doc(db, 'games', currentGameId)).then(docSnap => {
                const gameData = docSnap.data();
                gameData.turnOrder.forEach(pid => {
                    if (pid !== currentUserId && gameData.players[pid].isAlive) {
                        const btn = createModalBtn(gameData.players[pid].name, () => {
                            hideModal('target-selection-modal');
                            initiateAction(actionType, pid);
                        });
                        list.appendChild(btn);
                    }
                });
                modal.style.display = 'flex';
            });
            
            document.getElementById('cancel-target-btn').onclick = () => hideModal('target-selection-modal');
        }

    </script>
</body>
</html>
